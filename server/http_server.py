from aiohttp import web
from aiohttp.web import middleware
import asyncio
import json
import logging
from datetime import datetime

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('HTTPClipboardServer')

class ClipboardServer:
    def __init__(self, loop=None):
        self.clients = set()
        self.clipboard_content = ""
        self.history = []
        self.max_history = 3
        self.check_task = None
        self.loop = loop or asyncio.get_event_loop()
        logger.info("üìã ClipboardServer initialis√© avec succ√®s")
        
    async def cleanup(self):
        """Cleanup resources when shutting down"""
        if self.check_task and not self.check_task.done():
            self.check_task.cancel()
            try:
                await asyncio.wait_for(self.check_task, timeout=2.0)
            except (asyncio.CancelledError, asyncio.TimeoutError):
                logger.info("‚úÖ T√¢che de v√©rification du presse-papiers arr√™t√©e")

    async def _send_heartbeat(self, client, message):
        """Envoie un heartbeat √† un client sp√©cifique"""
        try:
            if not client.closed:
                await client.send_json(message)
                logger.debug(f"üíì Heartbeat envoy√© √† {client.remote}")
                return True
            return False
        except Exception as e:
            logger.error(f"‚ùå Erreur envoi heartbeat √† {client.remote}: {str(e)}")
            return False

    async def _cleanup_closed_clients(self):
        """Nettoie les clients d√©connect√©s"""
        closed_clients = [c for c in self.clients if c.closed]
        for client in closed_clients:
            self.clients.discard(client)
        if closed_clients:
            logger.info(f"üóëÔ∏è {len(closed_clients)} clients d√©connect√©s nettoy√©s")

    async def check_clipboard(self):
        """Boucle principale de v√©rification du presse-papiers"""
        logger.info("üöÄ Serveur de presse-papiers d√©marr√© - En attente de contenu...")
        
        self.clipboard_content = ""
        self.history = []
        heartbeat_count = 0
        
        try:
            while True:
                try:
                    # Attendre l'intervalle de heartbeat
                    await asyncio.sleep(15)
                    heartbeat_count += 1
                    
                    # Nettoyer les clients d√©connect√©s
                    await self._cleanup_closed_clients()
                    
                    # Log l'√©tat actuel
                    if self.clients:
                        logger.info(f"üîÑ {len(self.clients)} clients connect√©s (heartbeat #{heartbeat_count})")
                    else:
                        logger.debug(f"üîÑ En attente de connexions... (heartbeat #{heartbeat_count})")

                    # Envoyer les heartbeats si n√©cessaire
                    if self.clients:
                        heartbeat_msg = {
                            'type': 'heartbeat',
                            'timestamp': datetime.now().isoformat(),
                            'count': heartbeat_count
                        }
                        
                        # Envoyer en parall√®le √† tous les clients
                        tasks = [self._send_heartbeat(client, heartbeat_msg) 
                               for client in list(self.clients)]
                        await asyncio.gather(*tasks, return_exceptions=True)
                        
                except asyncio.CancelledError:
                    logger.info("‚úÖ Arr√™t de la boucle de v√©rification demand√©...")
                    raise
                    
                except Exception as e:
                    logger.error(f"‚ùå Erreur dans la boucle de v√©rification: {str(e)}", 
                               exc_info=not isinstance(e, asyncio.CancelledError))
                    await asyncio.sleep(5)  # Attendre avant de r√©essayer
                    
        except asyncio.CancelledError:
            logger.info("‚úÖ T√¢che de v√©rification arr√™t√©e avec succ√®s")
            raise
            
        except Exception as e:
            logger.critical(f"‚ùå Erreur fatale dans la boucle de v√©rification: {str(e)}", 
                          exc_info=True)
            raise
    async def broadcast_update(self):
        """Diffuse la mise √† jour du presse-papiers √† tous les clients connect√©s"""
        if not self.clipboard_content:
            logger.debug("Aucun contenu √† diffuser")
            return

        try:
            message = {
                'type': 'clipboard_update',
                'content': self.clipboard_content,
                'history': [
                    {
                        'content': item['content'], 
                        'timestamp': item['timestamp'].isoformat()
                    } 
                    for item in self.history
                ]
            }
            
            clients_to_remove = set()
            active_clients = 0
            
            # Pr√©parer les t√¢ches d'envoi
            send_tasks = []
            for client in list(self.clients):
                if client.closed:
                    clients_to_remove.add(client)
                    continue
                    
                async def send_to_client(ws):
                    try:
                        await ws.send_json(message)
                        return True
                    except Exception as e:
                        client_address = ws._req.remote if hasattr(ws, '_req') and hasattr(ws._req, 'remote') else 'client inconnu'
                        logger.debug(f"√âchec envoi √† {client_address}: {e}")
                        clients_to_remove.add(ws)
                        return False
                
                send_tasks.append(send_to_client(client))
            
            # Ex√©cuter les envois en parall√®le
            if send_tasks:
                results = await asyncio.gather(*send_tasks, return_exceptions=True)
                active_clients = sum(1 for r in results if r is True)
            
            # Nettoyer les clients d√©connect√©s
            if clients_to_remove:
                before = len(self.clients)
                self.clients -= clients_to_remove
                logger.info(f"üóëÔ∏è Nettoyage de {len(clients_to_remove)} clients d√©connect√©s")
            
            logger.info(f"üì° Mise √† jour diffus√©e √† {active_clients} clients")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de la diffusion: {e}", exc_info=True)

    async def websocket_handler(self, request):
        """G√®re les connexions WebSocket entrantes"""
        ws = web.WebSocketResponse(
            timeout=300,  # 5 minutes d'inactivit√©
            receive_timeout=300,  # 5 minutes
            heartbeat=30,  # Ping toutes les 30 secondes
            max_msg_size=10 * 1024 * 1024,  # 10MB
            autoping=True,
            autoclose=True
        )
        
        # Nettoyer les connexions ferm√©es
        self.clients = {c for c in self.clients if not c.closed}
        
        try:
            await ws.prepare(request)
            self.clients.add(ws)
            
            client_info = f"{request.remote} (total: {len(self.clients)})"
            logger.info(f"üîó Connexion √©tablie: {client_info}")
            
            # Envoyer l'√©tat initial
            try:
                if self.clipboard_content:
                    initial_msg = {
                        'type': 'clipboard_update',
                        'content': self.clipboard_content,
                        'history': [
                            {'content': item['content'], 
                             'timestamp': item['timestamp'].isoformat()}
                            for item in self.history
                        ]
                    }
                    await ws.send_json(initial_msg)
                    logger.debug(f"üì§ √âtat initial envoy√© √† {request.remote}")
                else:
                    await ws.send_json({
                        'type': 'status', 
                        'message': 'Bienvenue, pr√™t √† synchroniser le presse-papier'
                    })
            except Exception as e:
                logger.error(f"‚ùå Erreur envoi √©tat initial √† {request.remote}: {e}")
            
            # Boucle de r√©ception des messages
            async for msg in ws:
                if msg.type == web.WSMsgType.TEXT:
                    await self._handle_websocket_message(ws, msg)
                elif msg.type == web.WSMsgType.ERROR:
                    logger.error(f"‚ùå Erreur WebSocket avec {request.remote}: {ws.exception()}")
                    break
                elif msg.type == web.WSMsgType.CLOSE:
                    logger.info(f"üîå D√©connexion de {request.remote} (code: {ws.close_code})")
                    break
                
        except asyncio.CancelledError:
            logger.info(f"üîå Connexion annul√©e: {request.remote}")
            raise
            
        except Exception as e:
            logger.error(f"‚ùå Erreur avec {request.remote}: {e}", exc_info=True)
            
        finally:
            # Nettoyage
            if not ws.closed:
                try:
                    await ws.close()
                except Exception as e:
                    logger.error(f"‚ùå Erreur lors de la fermeture de la connexion: {e}")
            
            self.clients.discard(ws)
            logger.info(f"üëã D√©connect√©: {request.remote} (restants: {len(self.clients)})")
            
        return ws
        
    async def _handle_websocket_message(self, ws, msg):
        """Traite un message WebSocket entrant"""
        try:
            data = json.loads(msg.data)
            msg_type = data.get('type', 'unknown')
            client_address = ws._req.remote if hasattr(ws, '_req') and hasattr(ws._req, 'remote') else 'client inconnu'
            logger.debug(f" Message {msg_type} de {client_address}")
            
            if msg_type == 'clipboard_update':
                await self._process_clipboard_update(data, client_address)
                
        except json.JSONDecodeError:
            client_address = ws._req.remote if hasattr(ws, '_req') and hasattr(ws._req, 'remote') else 'client inconnu'
            logger.error(f" Message JSON invalide de {client_address}: {msg.data[:100]}")
        except Exception as e:
            logger.error(f" Erreur traitement message de {client_address}: {e}", exc_info=True)
    
    async def _process_clipboard_update(self, data, remote):
        """Traite une mise √† jour du presse-papiers"""
        try:
            if 'content' not in data:
                return
                
            self.clipboard_content = data['content']
            self.history.insert(0, {
                'content': self.clipboard_content,
                'timestamp': datetime.now()
            })
            
            # Limiter l'historique
            if hasattr(self, 'max_history') and len(self.history) > self.max_history:
                self.history = self.history[:self.max_history]
                
            # Diffuser la mise √† jour
            await self.broadcast_update()
            
        except Exception as e:
            logger.error(f"‚ùå Erreur traitement mise √† jour de {remote}: {e}", exc_info=True)

@middleware
async def cors_middleware(request, handler):
    response = await handler(request)
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, OPTIONS'
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    return response

async def create_app(loop=None):
    # Configuration du serveur avec des timeouts plus longs
    app = web.Application(middlewares=[cors_middleware], client_max_size=1024*1024*10, loop=loop)
    
    # Configuration des timeouts
    app['websocket_timeout'] = 300  # 5 minutes
    app['keepalive_timeout'] = 300  # 5 minutes
    
    server = ClipboardServer(loop=loop)
    
    # Nettoyage lors de l'arr√™t de l'application
    async def on_shutdown(app):
        logger.info("üîå Nettoyage des ressources de l'application...")
        await server.cleanup()
        
    async def on_startup(app):
        # Cr√©er et stocker la t√¢che de v√©rification dans le bon event loop
        server.check_task = asyncio.create_task(server.check_clipboard())
    
    app.on_startup.append(on_startup)
    app.on_shutdown.append(on_shutdown)
    
    # Configuration des routes
    app.router.add_route('GET', '/ws', server.websocket_handler)
    app.router.add_route('GET', '/health', lambda req: web.json_response({'status': 'ok'}))
    app.router.add_route('GET', '/', lambda req: web.json_response({
        'status': 'ok', 
        'message': 'Clipboard server running',
        'version': '1.0.0',
        'websocket_timeout': '300s',
        'keepalive': 'enabled'
    }))
    logger.info("üöÄ Serveur HTTP WebSocket d√©marr√© sur http://0.0.0.0:24900")
    logger.info("üì° WebSocket endpoint: ws://0.0.0.0:24900/ws")
    logger.info("üè• Health endpoint: http://0.0.0.0:24900/health")
    logger.info("üè† Root endpoint: http://0.0.0.0:24900/")
    return app

class ServerManager:
    def __init__(self):
        self.server_started = False
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        self.setup_signal_handlers()

    def setup_signal_handlers(self):
        for signame in ('SIGINT', 'SIGTERM'):
            self.loop.add_signal_handler(
                getattr(signal, signame),
                lambda s=signame: self.handle_shutdown(s)
            )

    def handle_shutdown(self, signame):
        """M√©thode conserv√©e pour compatibilit√©, mais non utilis√©e directement"""
        if not self.server_started:
            logger.info("\n‚úÖ Arr√™t du serveur avant le d√©marrage complet...")
            self.loop.stop()
            return

    def run(self):
        try:
            logger.info("üîß D√©marrage du serveur clipboard...")
            app = self.loop.run_until_complete(create_app(loop=self.loop))
            self.server_started = True
            logger.info("‚úÖ Serveur d√©marr√© avec succ√®s et pr√™t √† accepter des connexions")
            
            # Cr√©er le runner et d√©marrer le serveur manuellement
            runner = web.AppRunner(app)
            self.loop.run_until_complete(runner.setup())
            site = web.TCPSite(runner, '0.0.0.0', 24900)
            self.loop.run_until_complete(site.start())
            
            # D√©sactiver la gestion des signaux par aiohttp
            # et utiliser notre propre gestionnaire
            def shutdown():
                logger.info("\nüëã Arr√™t du serveur demand√©...")
                # Annuler toutes les t√¢ches en cours
                for task in asyncio.all_tasks(loop=self.loop):
                    task.cancel()
                # Arr√™ter le serveur
                self.loop.create_task(runner.cleanup())
                # Arr√™ter la boucle d'√©v√©nements
                self.loop.stop()
            
            # Configurer les gestionnaires de signaux
            for signame in ('SIGINT', 'SIGTERM'):
                self.loop.add_signal_handler(
                    getattr(signal, signame),
                    shutdown
                )
            
            # Lancer la boucle d'√©v√©nements
            logger.info("Appuyez sur Ctrl+C pour arr√™ter le serveur")
            self.loop.run_forever()
            
        except KeyboardInterrupt:
            logger.info("\nüëã Arr√™t du serveur demand√© via Ctrl+C")
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du d√©marrage du serveur: {e}")
            raise
        finally:
            if self.server_started:
                logger.info("üëã Arr√™t du serveur effectu√© avec succ√®s")
            # Nettoyer les t√¢ches restantes
            tasks = asyncio.all_tasks(loop=self.loop)
            for task in tasks:
                task.cancel()
            # Attendre que les t√¢ches soient annul√©es
            if tasks:
                self.loop.run_until_complete(asyncio.gather(*tasks, return_exceptions=True))
            # Fermer la boucle d'√©v√©nements
            self.loop.close()

if __name__ == '__main__':
    import signal
    server = ServerManager()
    server.run()