from aiohttp import web
from aiohttp.web import middleware
import asyncio
import json
import logging
from datetime import datetime

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('HTTPClipboardServer')

class ClipboardServer:
    def __init__(self, loop=None):
        self.clients = {}  # Dictionnaire pour stocker les clients avec leur ID
        self.client_info = {}  # Dictionnaire pour stocker les infos des clients (adresse IP, ID machine, etc.)
        self.clipboard_content = ""
        self.history = []
        self.max_history = 3
        self.check_task = None
        self.loop = loop or asyncio.get_event_loop()
        logger.info("üìã ClipboardServer initialis√© avec succ√®s")
        
    async def cleanup(self):
        """Cleanup resources when shutting down"""
        if self.check_task and not self.check_task.done():
            self.check_task.cancel()
            try:
                await asyncio.wait_for(self.check_task, timeout=2.0)
            except (asyncio.CancelledError, asyncio.TimeoutError):
                logger.info("‚úÖ T√¢che de v√©rification du presse-papiers arr√™t√©e")

    async def _send_heartbeat(self, client, message):
        """Envoie un heartbeat √† un client sp√©cifique"""
        try:
            if not client.closed:
                await client.send_json(message)
                logger.debug(f"üíì Heartbeat envoy√© √† {client.remote}")
                return True
            return False
        except Exception as e:
            logger.error(f"‚ùå Erreur envoi heartbeat √† {client.remote}: {str(e)}")
            return False

    async def _cleanup_closed_clients(self):
        """Nettoie les clients d√©connect√©s"""
        closed_clients = [client_id for client_id, client in self.clients.items() if client.closed]
        for client_id in closed_clients:
            self.clients.pop(client_id, None)
            self.client_info.pop(client_id, None)
        if closed_clients:
            logger.info(f"üóëÔ∏è {len(closed_clients)} clients d√©connect√©s nettoy√©s")

    async def check_clipboard(self):
        """Boucle principale de v√©rification du presse-papiers"""
        logger.info("üöÄ Serveur de presse-papiers d√©marr√© - En attente de contenu...")
        
        self.clipboard_content = ""
        self.history = []
        heartbeat_count = 0
        
        try:
            while True:
                try:
                    # Attendre l'intervalle de heartbeat
                    await asyncio.sleep(15)
                    heartbeat_count += 1
                    
                    # Nettoyer les clients d√©connect√©s
                    await self._cleanup_closed_clients()
                    
                    # Log l'√©tat actuel
                    if self.clients:
                        logger.info(f"üîÑ {len(self.clients)} clients connect√©s (heartbeat #{heartbeat_count})")
                    else:
                        logger.debug(f"üîÑ En attente de connexions... (heartbeat #{heartbeat_count})")

                    # Envoyer les heartbeats si n√©cessaire
                    if self.clients:
                        heartbeat_msg = {
                            'type': 'heartbeat',
                            'timestamp': datetime.now().isoformat(),
                            'count': heartbeat_count
                        }
                        
                        # Envoyer en parall√®le √† tous les clients
                        tasks = [self._send_heartbeat(client, heartbeat_msg) 
                               for client in list(self.clients)]
                        await asyncio.gather(*tasks, return_exceptions=True)
                        
                except asyncio.CancelledError:
                    logger.info("‚úÖ Arr√™t de la boucle de v√©rification demand√©...")
                    raise
                    
                except Exception as e:
                    logger.error(f"‚ùå Erreur dans la boucle de v√©rification: {str(e)}", 
                               exc_info=not isinstance(e, asyncio.CancelledError))
                    await asyncio.sleep(5)  # Attendre avant de r√©essayer
                    
        except asyncio.CancelledError:
            logger.info("‚úÖ T√¢che de v√©rification arr√™t√©e avec succ√®s")
            raise
            
        except Exception as e:
            logger.critical(f"‚ùå Erreur fatale dans la boucle de v√©rification: {str(e)}", 
                          exc_info=True)
            raise
    async def broadcast_update(self, origin_client_id=None):
        """Diffuse la mise √† jour du presse-papiers √† tous les clients connect√©s"""
        if not self.clipboard_content:
            logger.debug("Aucun contenu √† diffuser")
            return

        try:
            # Pr√©parer l'historique pour l'envoi
            history_to_send = []
            for item in self.history:
                # G√©rer le timestamp qu'il soit une cha√Æne ou un objet datetime
                timestamp = item.get('timestamp')
                if hasattr(timestamp, 'isoformat'):
                    timestamp_str = timestamp.isoformat()
                else:
                    # Si c'est d√©j√† une cha√Æne, l'utiliser directement
                    timestamp_str = str(timestamp) if timestamp is not None else datetime.now().isoformat()
                
                history_to_send.append({
                    'content': item.get('content', ''),
                    'timestamp': timestamp_str,
                    'machine_id': item.get('machine_id', 'unknown'),
                    'hostname': item.get('hostname', 'Unknown'),
                    'source': item.get('source', 'unknown')
                })
            
            message = {
                'type': 'clipboard_update',
                'content': self.clipboard_content,
                'history': history_to_send
            }
            
            # Ajouter l'ID de la machine d'origine si disponible
            if origin_client_id:
                message['origin_machine_id'] = origin_client_id
            
            clients_to_remove = set()
            active_clients = 0
            
            # Pr√©parer les t√¢ches d'envoi
            send_tasks = []
            for client_id, client_ws in list(self.clients.items()):
                if client_ws.closed:
                    clients_to_remove.add(client_ws)
                    continue
                    
                async def send_to_client(ws, cid):
                    try:
                        # Ajouter l'ID de la machine d'origine au message
                        client_message = message.copy()
                        client_message['current_machine_id'] = cid
                        await ws.send_json(client_message)
                        return True
                    except Exception as e:
                        client_address = ws._req.remote if hasattr(ws, '_req') and hasattr(ws._req, 'remote') else 'client inconnu'
                        logger.debug(f"√âchec envoi √† {client_address}: {e}")
                        clients_to_remove.add(ws)
                        return False
                
                send_tasks.append(send_to_client(client_ws, client_id))
            
            # Ex√©cuter les envois en parall√®le
            if send_tasks:
                results = await asyncio.gather(*send_tasks, return_exceptions=True)
                active_clients = sum(1 for r in results if r is True)
            
            # Nettoyer les clients d√©connect√©s
            if clients_to_remove:
                before = len(self.clients)
                for client_id in clients_to_remove:
                    self.clients.pop(client_id, None)
                    self.client_info.pop(client_id, None)
                logger.info(f"üóëÔ∏è Nettoyage de {len(clients_to_remove)} clients d√©connect√©s")
                
            return active_clients
            
        except Exception as e:
            return 0
    
    async def websocket_handler(self, request):
        """G√®re les connexions WebSocket entrantes"""
        ws = web.WebSocketResponse(
            heartbeat=30.0,
            max_msg_size=10*1024*1024,  # 10MB max
            timeout=300.0,  # 5 minutes
            autoping=True,
            receive_timeout=300.0
        )
        
        # G√©n√©rer un ID unique pour ce client
        client_id = f"{request.remote}_{id(ws)}"
        
        try:
            await ws.prepare(request)
            
            # Ajouter le client aux listes
            self.clients[client_id] = ws
            self.client_info[client_id] = {
                'ip': request.remote,
                'connected_at': datetime.now().isoformat(),
                'last_seen': datetime.now().isoformat()
            }
            
            logger.info(f"üîó Connexion √©tablie: {request.remote} (ID: {client_id[:8]}...)")
            
            # Envoyer l'√©tat initial
            try:
                if self.clipboard_content:
                    # Pr√©parer l'historique pour l'envoi initial
                    history_to_send = []
                    for item in self.history:
                        # G√©rer le timestamp qu'il soit une cha√Æne ou un objet datetime
                        timestamp = item.get('timestamp')
                        if hasattr(timestamp, 'isoformat'):
                            timestamp_str = timestamp.isoformat()
                        else:
                            timestamp_str = str(timestamp) if timestamp is not None else datetime.now().isoformat()
                        
                        history_to_send.append({
                            'content': item.get('content', ''),
                            'timestamp': timestamp_str,
                            'machine_id': item.get('machine_id', 'unknown'),
                            'hostname': item.get('hostname', 'Unknown'),
                            'source': item.get('source', 'unknown')
                        })
                    
                    initial_msg = {
                        'type': 'clipboard_update',
                        'content': self.clipboard_content,
                        'history': history_to_send,
                        'client_id': client_id
                    }
                    await ws.send_json(initial_msg)
                    logger.debug(f"üì§ √âtat initial envoy√© √† {request.remote}")
                else:
                    await ws.send_json({
                        'type': 'status', 
                        'message': 'Bienvenue, pr√™t √† synchroniser le presse-papier',
                        'client_id': client_id
                    })
                
                # Envoyer √©galement les informations de connexion actuelles
                await ws.send_json({
                    'type': 'connection_info',
                    'status': 'connected',
                    'client_id': client_id,
                    'server_time': datetime.now().isoformat()
                })
                
            except Exception as e:
                logger.error(f"‚ùå Erreur envoi √©tat initial √† {request.remote}: {e}", exc_info=True)
            
            # Boucle de r√©ception des messages
            async for msg in ws:
                if msg.type == web.WSMsgType.TEXT:
                    # Mettre √† jour le last_seen
                    if client_id in self.client_info:
                        self.client_info[client_id]['last_seen'] = datetime.now().isoformat()
                    await self._handle_websocket_message(ws, msg, client_id)
                elif msg.type == web.WSMsgType.ERROR:
                    logger.error(f"‚ùå Erreur WebSocket avec {request.remote}: {ws.exception()}")
                    break
                elif msg.type == web.WSMsgType.CLOSE:
                    logger.info(f"üîå D√©connexion de {request.remote} (code: {ws.close_code})")
                    break
                
        except asyncio.CancelledError:
            logger.info(f"üîå Connexion annul√©e: {request.remote}")
            raise
            
        except Exception as e:
            logger.error(f"‚ùå Erreur avec {request.remote}: {e}", exc_info=True)
            
        finally:
            # Nettoyage
            if not ws.closed:
                try:
                    await ws.close()
                except Exception as e:
                    logger.error(f"‚ùå Erreur lors de la fermeture de la connexion: {e}")
            
            # Supprimer le client des listes
            self.clients.pop(client_id, None)
            self.client_info.pop(client_id, None)
            
            logger.info(f"üëã D√©connect√©: {request.remote} (restants: {len(self.clients)})")
            
        return ws
        
    async def _handle_websocket_message(self, ws, msg, client_id=None):
        """Traite un message WebSocket entrant"""
        try:
            data = json.loads(msg.data)
            msg_type = data.get('type', 'unknown')
            
            # Obtenir les infos du client
            client_info = self.client_info.get(client_id, {})
            client_ip = client_info.get('ip', 'inconnu')
            
            logger.debug(f"üì• Message {msg_type} re√ßu de {client_ip} (ID: {client_id[:8] if client_id else 'inconnu'})")
            logger.debug(f"üìã Contenu du message: {json.dumps(data, ensure_ascii=False)[:200]}...")
            
            if msg_type == 'client_identify':
                # Mettre √† jour les informations du client
                if client_id:
                    self.client_info[client_id].update({
                        'machine_id': data.get('machine_id', client_id),
                        'hostname': data.get('hostname', 'Unknown'),
                        'user_agent': data.get('user_agent', 'Unknown'),
                        'last_seen': datetime.now().isoformat()
                    })
                    logger.info(f"üÜî Client identifi√©: {self.client_info[client_id]['hostname']} ({client_id[:8]}...)")
                    
                    # Envoyer un accueil personnalis√©
                    welcome_msg = {
                        'type': 'status',
                        'message': f'Connect√© en tant que {self.client_info[client_id]["hostname"]}'
                    }
                    await ws.send_json(welcome_msg)
                    
            elif msg_type == 'clipboard_update':
                logger.info(f"üìã Mise √† jour du presse-papiers re√ßue de {client_ip} (ID: {client_id[:8] if client_id else 'inconnu'})")
                logger.debug(f"üìã Donn√©es brutes: {data}")
                
                # Ajouter les infos de la machine d'origine
                if client_id and client_id in self.client_info:
                    # Toujours utiliser le hostname du client s'il est disponible
                    client_hostname = self.client_info[client_id].get('hostname', 'Unknown')
                    
                    logger.debug(f"üîç Client trouv√©: ID={client_id}, Hostname={client_hostname}")
                    
                    # Mettre √† jour les donn√©es avec les informations du client
                    data.update({
                        'machine_id': client_id,
                        'hostname': client_hostname,
                        'source': 'remote',
                        'timestamp': datetime.now().isoformat()
                    })
                else:
                    logger.warning(f"‚ö†Ô∏è Client non trouv√© pour l'ID: {client_id}")
                
                # Traiter la mise √† jour du presse-papiers
                logger.debug("üîÑ Traitement de la mise √† jour du presse-papiers...")
                await self._process_clipboard_update(data, client_ip)
                logger.info("‚úÖ Mise √† jour du presse-papiers trait√©e avec succ√®s")
                
        except json.JSONDecodeError as e:
            logger.error(f" Message JSON invalide de {client_ip}: {msg.data[:100]}")
        except Exception as e:
            logger.error(f" Erreur traitement message de {client_ip}: {str(e)}")
            logger.debug("D√©tails de l'erreur:", exc_info=True)
    
    async def _process_clipboard_update(self, data, remote):
        """Traite une mise √† jour du presse-papiers"""
        try:
            logger.debug(f"üîß Traitement de la mise √† jour du presse-papiers de {remote}")
            logger.debug(f"üìÑ Donn√©es re√ßues: {json.dumps(data, ensure_ascii=False)[:500]}...")
            
            if 'content' not in data:
                logger.warning(f"‚ö†Ô∏è Mise √† jour du presse-papiers sans contenu re√ßue de {remote}")
                return
                
            logger.debug(f"üìù Contenu re√ßu (longueur: {len(str(data.get('content', '')))})")
            
            # Pr√©parer l'√©l√©ment avec des valeurs par d√©faut coh√©rentes
            timestamp = data.get('timestamp')
            if not timestamp:
                timestamp = datetime.now().isoformat()
            
            # Cr√©er le nouvel √©l√©ment avec toutes les m√©tadonn√©es disponibles
            new_item = {
                'content': data['content'],
                'timestamp': timestamp,
                'machine_id': data.get('machine_id', 'unknown'),
                'hostname': data.get('hostname', 'Unknown'),
                'source': data.get('source', 'unknown'),
                'remote': remote
            }
            
            # Mettre √† jour le contenu du presse-papiers
            self.clipboard_content = data['content']
            
            # Ajouter √† l'historique
            self.history.insert(0, new_item)
            
            # Limiter la taille de l'historique
            if hasattr(self, 'max_history') and len(self.history) > self.max_history:
                self.history = self.history[:self.max_history]
                
            # Diffuser la mise √† jour √† tous les clients connect√©s
            logger.debug("üì¢ Diffusion de la mise √† jour √† tous les clients...")
            await self.broadcast_update()
            logger.debug("‚úÖ Mise √† jour diffus√©e avec succ√®s")
            
            logger.info(f"üìã Presse-papiers mis √† jour par {new_item.get('hostname', 'unknown')} ({remote})")
            logger.debug(f"üìã Nouveau contenu: {str(new_item.get('content', ''))[:100]}...")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du traitement de la mise √† jour du presse-papiers de {remote}: {e}", exc_info=True)
            
    async def handle_hostname(self, request):
        """Renvoie le nom d'h√¥te du serveur"""
        import socket
        hostname = socket.gethostname()
        return web.json_response({
            'hostname': hostname,
            'fqdn': socket.getfqdn(),
            'ip': socket.gethostbyname(hostname)
        })

@middleware
async def cors_middleware(request, handler):
    response = await handler(request)
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, OPTIONS'
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'
    return response

async def create_app(loop=None):
    # Configuration du serveur avec des timeouts plus longs
    app = web.Application(middlewares=[cors_middleware],
                         client_max_size=1024*1024*10,
                         loop=loop)
    
    # Configuration des timeouts et tailles maximales
    app['client_timeout'] = 300  # 5 minutes
    app['websocket_timeout'] = 300  # 5 minutes
    app['keepalive_timeout'] = 300  # 5 minutes
    app['ping_interval'] = 30  # Envoi d'un ping toutes les 30 secondes
    app['websocket_max_msg_size'] = 10 * 1024 * 1024  # 10MB
    
    server = ClipboardServer(loop=loop)
    
    # Nettoyage lors de l'arr√™t de l'application
    async def on_shutdown(app):
        logger.info("üîå Nettoyage des ressources de l'application...")
        await server.cleanup()
        
    async def on_startup(app):
        # Cr√©er et stocker la t√¢che de v√©rification dans le bon event loop
        server.check_task = asyncio.create_task(server.check_clipboard())
    
    app.on_startup.append(on_startup)
    app.on_shutdown.append(on_shutdown)
    
    # Configuration des routes
    app.router.add_route('GET', '/ws', server.websocket_handler)
    app.router.add_route('GET', '/health', lambda req: web.json_response({'status': 'ok'}))
    app.router.add_route('GET', '/hostname', server.handle_hostname)
    app.router.add_route('GET', '/', lambda req: web.json_response({
        'status': 'ok', 
        'message': 'Clipboard server running',
        'version': '1.0.0',
        'websocket_timeout': '300s',
        'keepalive': 'enabled',
        'endpoints': {
            'ws': '/ws',
            'health': '/health',
            'hostname': '/hostname'
        }
    }))
    logger.info("üöÄ Serveur HTTP WebSocket d√©marr√© sur http://0.0.0.0:24900")
    logger.info("üì° WebSocket endpoint: ws://0.0.0.0:24900/ws")
    logger.info("üè• Health endpoint: http://0.0.0.0:24900/health")
    logger.info("üè† Root endpoint: http://0.0.0.0:24900/")
    return app

class ServerManager:
    def __init__(self):
        self.server_started = False
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        self.setup_signal_handlers()

    def setup_signal_handlers(self):
        for signame in ('SIGINT', 'SIGTERM'):
            self.loop.add_signal_handler(
                getattr(signal, signame),
                lambda s=signame: self.handle_shutdown(s)
            )

    def handle_shutdown(self, signame):
        """M√©thode conserv√©e pour compatibilit√©, mais non utilis√©e directement"""
        if not self.server_started:
            logger.info("\n‚úÖ Arr√™t du serveur avant le d√©marrage complet...")
            self.loop.stop()
            return

    def run(self):
        try:
            logger.info("üîß D√©marrage du serveur clipboard...")
            app = self.loop.run_until_complete(create_app(loop=self.loop))
            self.server_started = True
            logger.info("‚úÖ Serveur d√©marr√© avec succ√®s et pr√™t √† accepter des connexions")
            
            # Cr√©er le runner et d√©marrer le serveur manuellement
            runner = web.AppRunner(app)
            self.loop.run_until_complete(runner.setup())
            site = web.TCPSite(runner, '0.0.0.0', 24900)
            self.loop.run_until_complete(site.start())
            
            # D√©sactiver la gestion des signaux par aiohttp
            # et utiliser notre propre gestionnaire
            def shutdown():
                logger.info("\nüëã Arr√™t du serveur demand√©...")
                # Annuler toutes les t√¢ches en cours
                for task in asyncio.all_tasks(loop=self.loop):
                    task.cancel()
                # Arr√™ter le serveur
                self.loop.create_task(runner.cleanup())
                # Arr√™ter la boucle d'√©v√©nements
                self.loop.stop()
            
            # Configurer les gestionnaires de signaux
            for signame in ('SIGINT', 'SIGTERM'):
                self.loop.add_signal_handler(
                    getattr(signal, signame),
                    shutdown
                )
            
            # Lancer la boucle d'√©v√©nements
            logger.info("Appuyez sur Ctrl+C pour arr√™ter le serveur")
            self.loop.run_forever()
            
        except KeyboardInterrupt:
            logger.info("\nüëã Arr√™t du serveur demand√© via Ctrl+C")
        except Exception as e:
            logger.error(f"‚ùå Erreur lors du d√©marrage du serveur: {e}")
            raise
        finally:
            if self.server_started:
                logger.info("üëã Arr√™t du serveur effectu√© avec succ√®s")
            # Nettoyer les t√¢ches restantes
            tasks = asyncio.all_tasks(loop=self.loop)
            for task in tasks:
                task.cancel()
            # Attendre que les t√¢ches soient annul√©es
            if tasks:
                self.loop.run_until_complete(asyncio.gather(*tasks, return_exceptions=True))
            # Fermer la boucle d'√©v√©nements
            self.loop.close()

if __name__ == '__main__':
    import signal
    server = ServerManager()
    server.run()